#													Cotrex-M4-UART

##	1.实验目的

熟悉 STM32CubeIDE 工具软件的使用。

掌握 STM32CubeIDE 软件的基本设计流程和设计步骤，能够使用工具进行设计、编程、

仿真调试。

学习 UART 串口的使用方法，掌握如何利用 STM32MP157A 芯片的串口输入输出。

##	2.实验环境

FS-MP1A 开发平台

ST-Link 仿真器

STM32CubeIDE 开发软件

PC 机 XP、Window7/10 (32/64bit)

串口调试工具

##	3.实验原理

串口是计算机上一种非常通用设备通信的协议（不要与通用串行总线 Universal Serial Bus 或者 USB 混淆）。大多数计算

机包含两个基于 RS232 的串口。串口同时也是仪器仪表设备通用的通信协议；很多 GPIB(通用接口总线)兼容的设备也带

有 RS-232 口。同时，串口通信协议也可以用于获取远程采集设备的数据。

串口通信的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的

并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并

且能够实现远距离通信。典型地，串口用于 ASCII 码字符的传输。通信使用 3 根线完成：

（1）地线，（2）发送，（3）接收。

由于串口通信是异步的，端口能够在一根线上发送数据同时在

另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、

数据位、停止位和奇偶校验。

对于两个进行通行的端口，这些参数必须匹配：

**波特率：**这是一个衡量通信速度的参数。它表示每秒钟传送的 bit 的个数。例如 300 波

特表示每秒钟发送 300 个 bit。当我们提到时钟周期时，我们就是指波特率例如如果协议需

要 4800 波特率，那么时钟是 4800Hz。这意味着串口通信在数据线上的采样率为 4800Hz。

通常电话线的波特率为 14400，28800 和 36600。波特率可以远远大于这些值，但是波特率

和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是 GPIB 设备

的通信。

**数据位：**这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不

会是 8 位的，标准的值是 5、7 和 8 位。如何设置取决于你想传送的信息。比如，标准的

ASCII 码是 0～127（7 位）。扩展的 ASCII 码是 0～255（8 位）。如果数据使用简单的文本

（标准 ASCII 码），那么每个数据包使用 7 位数据。每个包是指一个字节，包括开始/停止位，

数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。

**停止位：**用于表示单个包的最后一位。典型的值为 1 ，1.5 和 2 位。这里的 1.5 位的数据宽度，就是 1.5 个波特率，由于

数据是在传输线上定时的，并且每一个设备有其自己的时钟，

很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并

且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越

大，但是数据传输率同时也越慢。

**奇偶校验位：**在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。

当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一

位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是 011，那么对

于偶校验，校验位为 0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位 1 ，这样就

有 3 个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使

得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收

数据是否不同步.

**硬件流控制****:** 硬件流控制常用的有 RTS/CTS 流控制和 DTR/ R（数据终端就绪/数据设置

就绪）流控制。硬件流控制必须将相应的电缆线连上，用 RTS/CTS（请求发送/清除发送）

流控制时，应将通讯两端的 RTS、CTS 线对应相连，数据终端设备（如计算机）使用 RTS

来起始调制解调器或其它数据通讯设备的数据流，而数据通讯设备（如调制解调器）则用

CTS 来起动和暂停来自计算机的数据流。这种硬件握手方式的过程为：我们在编程时根据接

收端缓冲区大小设置一个高位标志（可为缓冲区大小的 75％）和一个低位标志（可为缓冲

区大小的 25％），当缓冲区内数据量达到高位时，我们在接收端将 CTS 线置低电平（送逻辑

0），当发送端的程序检测到 CTS 为低后，就停止发送数据，直到接收端缓冲区的数据量低

于低位而将 CTS 置高电平。RTS 则用来标明接收设备有没有准备好接收数据。

常用的流控制还有还有 DTR/ R（数据终端就绪/数据设置就绪）。我们在此不再详述。

STM32 串口设置一般可以总结为如下几个步骤：

1）串口时钟使能，GPIO 时钟使能

2）设置引脚复用映射

3）GPIO 初始化设置,模式为复用功能

4）串口参数初始化：设置波特率，字长，奇偶校验等参数

5）开启中断并初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）

6）使能串口

7）编写中断处理函数

串口硬件原理图：

![image-20231231201020909](.\Picture\image-20231231201020909.png)

HAL 库函数解析：

```c
HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t 

Timeout);

HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t 

Timeout);
```

这两个函数是轮询方式发送和接收

```c

HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);

HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);

```

这两个函数是以中断方式发送和接收。具体传参详见工程。

注意：这两个函数里为指定缓冲区和大小并开启中断。实际上数据还在中断里处理

HAL 库提供了用户中断处理函数方式，是调用回调函数。

```c
接收中断在用户代码里重定义 void HAL_UART_RxCpltCallback(UART_HandleTypeDef 

*huart)

发送中断在用户代码里重定义 void HAL_UART_TxCpltCallback(UART_HandleTypeDef 

*huart);
```

##	4.实验步骤

 1.    创建工程

 2.    配置 UART4，勾选 Cortex-M4，Mode 选择 Asynchronous，NVIC Settings 勾选 Enabled 使

       能串口中断，搜索框搜索 PB2、PG11，分别配置为 UART4_RX、UART4_TX 
       ![image-20231231203243343](.\Picture\image-20231231203243343.png)

 3.    在 Code Generator 处选择为每个外设生成单独的 C 和 H 文件，这样设置方便阅读代码

 4.    可以在左侧工程文件夹找到 UART_CM4 子工程,打开 main.c
       ![image-20231231203529810](.\Picture\image-20231231203529810.png)

 5.    添加串口中断回调函数 HAL_UART_RxCpltCallback
       ![image-20231231204014809](.\Picture\image-20231231204014809.png)

 6.    在主函数中调用串口中断接收函数 HAL_UART_Receive_IT(&huart4, Buff, 5);配置完成或导入工程后进行程序下载,程序编译、下载.

       ![image-20231231204307704](.\Picture\image-20231231204307704.png)



##	5.实验结果

连接串口线，打开串口调试助手，选择串口号，波特率 115200，打开串口，发送 5 个字符，可以看到也成功接收到发送的字符

一直打印指定字符串。
![image-20231231224342299](.\Picture\image-20231231224342299.png)

![image-20231231224047004](.\Picture\image-20231231224047004.png)

